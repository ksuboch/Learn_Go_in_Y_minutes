// Однострочный комментарий
/* Много
строчный комментарий*/

package main

import (
	"fmt"       // пакет в стандартной библиотеке Go
	"io/ioutil" // реализация функция ввода/вывода
	m "math"    // импортировать math под локальным именем m
	"net/http"  //веб сервер
	"strconv"   // конвертирование типов в строки и обратно
)

// Объявление функции main. Это специальная функция,
// служащая точкой входа для исполняемой программы.
func main() {
	// Println выводит строку в stdout
	// Это функция из пакета fmt
	fmt.Println("Hello world!")
	beyondHello()
}

// Параметры функции указываются в круглых скобках
// пустые скобки обязательны, даже если параметров нет
func beyondHello() {
	var x int // Переменные должны быть объявлены до их использования
	x = 3     // Присвоение значения переменной
	// Краткое определение := позволяет объявить переменную с автоматической
	// подстановкой типа значчения
	y := 4
	sum, prod := learnMultiple(x, y)        // Функция возвращает два значения
	fmt.Println("sum:", sum, "prod:", prod) // Простой вывод
	learnTypes()
}

// Функция, имеющая входные параметры и возвращающая несколько значений
func learnMultiple(x, y int) (sum, prod int) {
	return x + y, x * y // возврат двух значений
}

func learnTypes() {
	// тип string
	s := "Learn Go!"

	s2 := `"Чистый" строковый литерал
может содержать переносы строк`

	// Символы не из ASCII
	g := 'Σ' // тип rune - алиас для типа int32, содержит символ юникода

	f := 3.141595 // float64, 64-х битное число с плавающей точкой
	c := 3 + 4i   // complex128, внутри себя содержит два float64

	// Синтаксис var  с инициализ0ациями
	var u uint = 7 // беззнаковое, но размер зависит от реализации, как и у int
	var pi float32 = 22. / 7

	// Синтаксис приведения типа с определением
	n := byte('\n') // byte - это алиас для uint8

	// Массивы имеют фиксированный размер на момент компиляции
	var a4 [4]int           // массив из 4-х int, инициализирован нулями
	a3 := [...]int{3, 1, 5} // массив из 3-х int, ручная инициализация

	// Слайсы (slices) имеют динамическую длину. И массивы, и слайсы имеют свои
	// преимущества, но слайсы используются гораздо чаще
	s3 := []int{4, 5, 9}    // в отличие от a3, тут нет троеточия
	s4 := make([]int, 4)    // выделение памяти для слайса из 4-х int (нули)
	var d2 [][]float64      // только объявление, память не выделяется
	bs := []byte("a slice") // синтаксис приведения типов

	p, q := learnMemory() // объявление p и q как указателей на int
	fmt.Println(*p, *q)   // * извлекает указатель. Печатает два int-а

	// Map, также как и словарь или хэш из некоторых других языков, является
	// ассоциативным массивом с динамически изменяемым размером.
	m := map[string]int{"three": 3, "four": 4}
	m["one"] = 1

	delete(m, "three") // встроенная функция, удаляет элемент из map-а

	// неиспользуемые переменные в Go считаются ошибкой
	// Нижнее подчеркивание позволяет игнорировать такие переменные
	_, _, _, _, _, _, _, _, _ = s2, g, f, u, pi, n, a3, s4, bs
	// Вывод считается использованием переменной
	fmt.Println(s, c, a4, s3, d2, m)

	learnFlowControl() // управление потоком
}

// у Go есть сборщик мусора. В нём есть указатели, но нет арифметики
// указателей. Вы можете допустить ошибку с указателем на nil, но не с
// инкрементацией указателя
func learnMemory() (p, q *int) {
	// именованные возвращаемые значения p и q являются указателями на int
	p = new(int) // встроенная функция new выделяет память
	// выделенный int проинициализирован нулём, p больше не содержит nil
	s := make([]int, 20) // Выделение единого блока памяти под 20 int-ов
	s[3] = 7             // Присвоить значение одному из них
	r := -2              // определить ещё одну локальную переменную
	return &s[3], &r     // Амперсанд(&) обозначает получение адреса переменной
}

func expensiveComputation() float64 {
	return m.Exp(10)
}

func learnFlowControl() {
	// if-ы всегда требуют наличия фигурных скобок, но не круглых
	if true {
		fmt.Println("told ya")
	}
	// форматирование кода стандартизировано утилитой "go fmt"
	if false {
		// не выполняется
	} else {
		// выполняется
	}
	// вместо нескольких if исползуется switch
	x := 42.0
	switch x {
	case 0:
	case 1:
	case 42:
		// Case-ы в Go не "проваливаются" (неявный break)
	case 43:
		//  не выполняется
	}
	// for, как и if не требует круглх скобок
	// переменные, объявленные в for и if являются локальными
	for x := 0; x < 3; x++ { // ++ - это операция
		fmt.Println("итерация", x)
	}
	// здесь x == 42

	// for - единственный цикл в Go, но у него есть альтернативные формы
	for { // бесконечный цикл
		break    // не такой уж бесконечный
		continue // не выполнится
	}
	// как и в for, := в if-е означает объявление и присвоение значения y,
	// проверка y > x происходит после
	if y := expensiveComputation(); y > x {
		x = y
	}
	// Функции являются замыканиями
	xBig := func() bool {
		return x > 10000 // Ссылается на x, объявленный выше switch
	}
	fmt.Println("xBig", xBig()) // true (т.к. мы присвоили x = e^10)
	x = 1.3e3                   // тут x == 1300
	fmt.Println("xBig", xBig()) // Теперь false

	// метки
	goto love
love:

	learnDefer()
	learnInterfaces()
}

func learnDefer() (ok bool) {
	// отложенные (deferred) выражения выполняются сразу перед тем, как функция
	// возвратит значения
	defer fmt.Println("deferred statements execute in reverse (LIFO) order.")
	defer fmt.Println("\nThis line is being printed first because")
	// defer широко используется для закрытия файлов, чтобы закрывающая файл
	// функция находилась близко к открывающей
	return true
}

// Stringer объявление как интерфейса с одним методом, String
type Stringer interface {
	String() string
}

// объявление pair как структуры с двумя полями x и y типа int
type pair struct {
	x, y int
}

// объявление метода для типа pair; теперь pair реализует интерфейс Stringer
func (p pair) String() string { // p в данном случае называют receiver-ом
	// Sprintf - ещё одна функция из пакета fmt
	// Обращение к полям p через точчку
	return fmt.Sprintf("(%d, %d)", p.x, p.y)
}

func learnInterfaces() {
	// синтаксис с фигурными скобками это "литерал структуры". Он возвращает
	// проинициализированную структуру, а оператор := присваивает её p
	p := pair{3, 4}
	fmt.Println(p.String()) // вызов метода String у переменной p типа pair
	var i Stringer          // объявление i как типа с интерфейсом Stringer
	i = p                   // валидно, т.к. pair реализует Stringer
	// Вызов метода String у i типа Stringer
	fmt.Println(i.String())

	// Функция в пакете fmt сами всегда вызывают метод String у объектов для
	// получения их строкового представления
	fmt.Println(p) // вывод такой-же, как и выше
	fmt.Println(i) // вывод такой-же, как и выше

	learnVariadicParams("Learn", "learn", "learn again")
}

// функции могут иметь варьируемое количество параметров
func learnVariadicParams(myStrings ...interface{}) {
	// вывести все параметры с помощью итерации
	for _, param := range myStrings {
		fmt.Println("param:", param)
	}

	// передать все варьируемые параметры
	fmt.Println("params:", fmt.Sprintln(myStrings...))

	learnErrorHandling()
}

func learnErrorHandling() {
	// идиома ", ok" служит для обозначения корректного срабатывания чего-либо
	m := map[int]string{3: "three", 4: "four"}
	if x, ok := m[1]; !ok { // ок будет false, потому что 1 нет в map-е
		fmt.Println("тут ничего нет")
	} else {
		fmt.Println(x) // x содержал бы значение, если бы 1 был в map-e
	}
	// идиома ", err" служит для обозначения того, была ли ошибка или нет
	if _, err := strconv.Atoi("non-int"); err != nil { // _ игнорирует значение
		// выведет "strconv.ParseInt: parsing "non-int": invalid syntax"
		fmt.Println(err)
	}

	learnConcurrency()
}

func inc(i int, c chan int) {
	c <- i + 1 // когда channel слева, <- является оператором "отправки"
}

// будем ипользовать функцию inc для конкурентной инкрементации чисел
func learnConcurrency() {
	// тот же make, что и в случае со slice. Он предназначен для выделения
	// памяти и инициализации типов slice, map и channel
	c := make(chan int)
	// старт трех конкурентнов gorutine. Числа будут инкрементированы
	// конкурентно и, может быть параллельно, если машинка
	// правильно сконфигурирована и позволяет это делать. Все они будут отправлены в один
	// и тот же канал
	go inc(0, c) // Go начинает новую горутину
	go inc(10, c)
	go inc(-805, c)
	// Считывание всех трёх результатов из канала и вывод на экран
	// Нет никакой гарантии в каком порядке они будут выведены
	fmt.Println(<-c, <-c, <-c) // канал справа, <- обозначает "получение"

	cs := make(chan string)       // другой канал содержит строки
	cc := make(chan chan string)  // канал каналов со строками
	go func() { c <- 84 }()       // пуск новой горутины для отправки значения
	go func() { cs <- "wordy" }() // ещё раз, теперь для cs
	// select тоже что и switch, но работает с каналами. Он случайно выбирает
	// готовый для взаимодействия канал
	select {
	case i := <-c: // получченное значение можно присвоить переменной
		fmt.Printf("это %T", i)
	case <-cs: // либо это значение можно игнорировать
		fmt.Println("это строка")
	case <-cc: // пустой канал, не готтов для коммуникации
		fmt.Println("это не выполняется")
	}
	// В этой точке значение будет получено из c или cs. Одна горутина будет
	// завершена, другая останется заблокированной
	learnWebProgramming()
}

func learnWebProgramming() {
	// у ListenAndServe первый параметр это TCP адрес, который нужно слушать
	// второй параметр это интерфейс типа http.Handler
	err := http.ListenAndServe(":8080", pair{})
	fmt.Println(err) // не игнорируйте сообщения об ошибках
}

// Реализация интерфейса http.Handler для pair, только один метод ServerHTTP
func (p pair) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Обработка запроса и отправка данных методом из http.ResponseWriter
	w.Write([]byte("You learned Go in Y minutes!"))
}

func requestServer() {
	resp, err := http.Get("http://localhost:8080")
	fmt.Println(err)
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	fmt.Printf("\nWebserver said :`%s`", string(body))
}
